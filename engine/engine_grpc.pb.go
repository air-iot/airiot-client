// protoc -I ./ --go_out=. ./engine/engine.proto
// protoc -I ./ --go-grpc_out=. engine/engine.proto

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: engine/engine.proto

package engine

import (
	context "context"
	api "github.com/air-iot/api-client-go/v4/api"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	EngineService_Run_FullMethodName    = "/engine.EngineService/Run"
	EngineService_Resume_FullMethodName = "/engine.EngineService/Resume"
	EngineService_Revert_FullMethodName = "/engine.EngineService/Revert"
	EngineService_Fail_FullMethodName   = "/engine.EngineService/Fail"
)

// EngineServiceClient is the client API for EngineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineServiceClient interface {
	Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error)
	Resume(ctx context.Context, in *ResumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Revert(ctx context.Context, in *ResumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type engineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineServiceClient(cc grpc.ClientConnInterface) EngineServiceClient {
	return &engineServiceClient{cc}
}

func (c *engineServiceClient) Run(ctx context.Context, in *RunRequest, opts ...grpc.CallOption) (*RunResponse, error) {
	out := new(RunResponse)
	err := c.cc.Invoke(ctx, EngineService_Run_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) Resume(ctx context.Context, in *ResumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EngineService_Resume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) Revert(ctx context.Context, in *ResumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EngineService_Revert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *engineServiceClient) Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EngineService_Fail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EngineServiceServer is the server API for EngineService service.
// All implementations must embed UnimplementedEngineServiceServer
// for forward compatibility
type EngineServiceServer interface {
	Run(context.Context, *RunRequest) (*RunResponse, error)
	Resume(context.Context, *ResumeRequest) (*emptypb.Empty, error)
	Revert(context.Context, *ResumeRequest) (*emptypb.Empty, error)
	Fail(context.Context, *FailRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedEngineServiceServer()
}

// UnimplementedEngineServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEngineServiceServer struct {
}

func (UnimplementedEngineServiceServer) Run(context.Context, *RunRequest) (*RunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Run not implemented")
}
func (UnimplementedEngineServiceServer) Resume(context.Context, *ResumeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resume not implemented")
}
func (UnimplementedEngineServiceServer) Revert(context.Context, *ResumeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revert not implemented")
}
func (UnimplementedEngineServiceServer) Fail(context.Context, *FailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fail not implemented")
}
func (UnimplementedEngineServiceServer) mustEmbedUnimplementedEngineServiceServer() {}

// UnsafeEngineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServiceServer will
// result in compilation errors.
type UnsafeEngineServiceServer interface {
	mustEmbedUnimplementedEngineServiceServer()
}

func RegisterEngineServiceServer(s grpc.ServiceRegistrar, srv EngineServiceServer) {
	s.RegisterService(&EngineService_ServiceDesc, srv)
}

func _EngineService_Run_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).Run(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_Run_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).Run(ctx, req.(*RunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_Resume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).Resume(ctx, req.(*ResumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_Revert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).Revert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_Revert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).Revert(ctx, req.(*ResumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EngineService_Fail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EngineServiceServer).Fail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EngineService_Fail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EngineServiceServer).Fail(ctx, req.(*FailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EngineService_ServiceDesc is the grpc.ServiceDesc for EngineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EngineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.EngineService",
	HandlerType: (*EngineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Run",
			Handler:    _EngineService_Run_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _EngineService_Resume_Handler,
		},
		{
			MethodName: "Revert",
			Handler:    _EngineService_Revert_Handler,
		},
		{
			MethodName: "Fail",
			Handler:    _EngineService_Fail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine/engine.proto",
}

const (
	PluginService_HealthCheck_FullMethodName = "/engine.PluginService/HealthCheck"
	PluginService_Register_FullMethodName    = "/engine.PluginService/Register"
	PluginService_DebugStream_FullMethodName = "/engine.PluginService/DebugStream"
)

// PluginServiceClient is the client API for PluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PluginServiceClient interface {
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	Register(ctx context.Context, opts ...grpc.CallOption) (PluginService_RegisterClient, error)
	DebugStream(ctx context.Context, opts ...grpc.CallOption) (PluginService_DebugStreamClient, error)
}

type pluginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginServiceClient(cc grpc.ClientConnInterface) PluginServiceClient {
	return &pluginServiceClient{cc}
}

func (c *pluginServiceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, PluginService_HealthCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) Register(ctx context.Context, opts ...grpc.CallOption) (PluginService_RegisterClient, error) {
	stream, err := c.cc.NewStream(ctx, &PluginService_ServiceDesc.Streams[0], PluginService_Register_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginServiceRegisterClient{stream}
	return x, nil
}

type PluginService_RegisterClient interface {
	Send(*FlowResponse) error
	Recv() (*FlowRequest, error)
	grpc.ClientStream
}

type pluginServiceRegisterClient struct {
	grpc.ClientStream
}

func (x *pluginServiceRegisterClient) Send(m *FlowResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pluginServiceRegisterClient) Recv() (*FlowRequest, error) {
	m := new(FlowRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *pluginServiceClient) DebugStream(ctx context.Context, opts ...grpc.CallOption) (PluginService_DebugStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &PluginService_ServiceDesc.Streams[1], PluginService_DebugStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &pluginServiceDebugStreamClient{stream}
	return x, nil
}

type PluginService_DebugStreamClient interface {
	Send(*DebugResponse) error
	Recv() (*DebugRequest, error)
	grpc.ClientStream
}

type pluginServiceDebugStreamClient struct {
	grpc.ClientStream
}

func (x *pluginServiceDebugStreamClient) Send(m *DebugResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *pluginServiceDebugStreamClient) Recv() (*DebugRequest, error) {
	m := new(DebugRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PluginServiceServer is the server API for PluginService service.
// All implementations must embed UnimplementedPluginServiceServer
// for forward compatibility
type PluginServiceServer interface {
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	Register(PluginService_RegisterServer) error
	DebugStream(PluginService_DebugStreamServer) error
	mustEmbedUnimplementedPluginServiceServer()
}

// UnimplementedPluginServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPluginServiceServer struct {
}

func (UnimplementedPluginServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedPluginServiceServer) Register(PluginService_RegisterServer) error {
	return status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedPluginServiceServer) DebugStream(PluginService_DebugStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DebugStream not implemented")
}
func (UnimplementedPluginServiceServer) mustEmbedUnimplementedPluginServiceServer() {}

// UnsafePluginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginServiceServer will
// result in compilation errors.
type UnsafePluginServiceServer interface {
	mustEmbedUnimplementedPluginServiceServer()
}

func RegisterPluginServiceServer(s grpc.ServiceRegistrar, srv PluginServiceServer) {
	s.RegisterService(&PluginService_ServiceDesc, srv)
}

func _PluginService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_Register_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PluginServiceServer).Register(&pluginServiceRegisterServer{stream})
}

type PluginService_RegisterServer interface {
	Send(*FlowRequest) error
	Recv() (*FlowResponse, error)
	grpc.ServerStream
}

type pluginServiceRegisterServer struct {
	grpc.ServerStream
}

func (x *pluginServiceRegisterServer) Send(m *FlowRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pluginServiceRegisterServer) Recv() (*FlowResponse, error) {
	m := new(FlowResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _PluginService_DebugStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PluginServiceServer).DebugStream(&pluginServiceDebugStreamServer{stream})
}

type PluginService_DebugStreamServer interface {
	Send(*DebugRequest) error
	Recv() (*DebugResponse, error)
	grpc.ServerStream
}

type pluginServiceDebugStreamServer struct {
	grpc.ServerStream
}

func (x *pluginServiceDebugStreamServer) Send(m *DebugRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *pluginServiceDebugStreamServer) Recv() (*DebugResponse, error) {
	m := new(DebugResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PluginService_ServiceDesc is the grpc.ServiceDesc for PluginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.PluginService",
	HandlerType: (*PluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _PluginService_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Register",
			Handler:       _PluginService_Register_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DebugStream",
			Handler:       _PluginService_DebugStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "engine/engine.proto",
}

const (
	ExtensionService_HealthCheck_FullMethodName  = "/engine.ExtensionService/HealthCheck"
	ExtensionService_SchemaStream_FullMethodName = "/engine.ExtensionService/SchemaStream"
	ExtensionService_RunStream_FullMethodName    = "/engine.ExtensionService/RunStream"
)

// ExtensionServiceClient is the client API for ExtensionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExtensionServiceClient interface {
	HealthCheck(ctx context.Context, in *ExtensionHealthCheckRequest, opts ...grpc.CallOption) (*ExtensionHealthCheckResponse, error)
	SchemaStream(ctx context.Context, opts ...grpc.CallOption) (ExtensionService_SchemaStreamClient, error)
	RunStream(ctx context.Context, opts ...grpc.CallOption) (ExtensionService_RunStreamClient, error)
}

type extensionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExtensionServiceClient(cc grpc.ClientConnInterface) ExtensionServiceClient {
	return &extensionServiceClient{cc}
}

func (c *extensionServiceClient) HealthCheck(ctx context.Context, in *ExtensionHealthCheckRequest, opts ...grpc.CallOption) (*ExtensionHealthCheckResponse, error) {
	out := new(ExtensionHealthCheckResponse)
	err := c.cc.Invoke(ctx, ExtensionService_HealthCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *extensionServiceClient) SchemaStream(ctx context.Context, opts ...grpc.CallOption) (ExtensionService_SchemaStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExtensionService_ServiceDesc.Streams[0], ExtensionService_SchemaStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &extensionServiceSchemaStreamClient{stream}
	return x, nil
}

type ExtensionService_SchemaStreamClient interface {
	Send(*ExtensionResult) error
	Recv() (*ExtensionSchemaRequest, error)
	grpc.ClientStream
}

type extensionServiceSchemaStreamClient struct {
	grpc.ClientStream
}

func (x *extensionServiceSchemaStreamClient) Send(m *ExtensionResult) error {
	return x.ClientStream.SendMsg(m)
}

func (x *extensionServiceSchemaStreamClient) Recv() (*ExtensionSchemaRequest, error) {
	m := new(ExtensionSchemaRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *extensionServiceClient) RunStream(ctx context.Context, opts ...grpc.CallOption) (ExtensionService_RunStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ExtensionService_ServiceDesc.Streams[1], ExtensionService_RunStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &extensionServiceRunStreamClient{stream}
	return x, nil
}

type ExtensionService_RunStreamClient interface {
	Send(*ExtensionResult) error
	Recv() (*ExtensionRunRequest, error)
	grpc.ClientStream
}

type extensionServiceRunStreamClient struct {
	grpc.ClientStream
}

func (x *extensionServiceRunStreamClient) Send(m *ExtensionResult) error {
	return x.ClientStream.SendMsg(m)
}

func (x *extensionServiceRunStreamClient) Recv() (*ExtensionRunRequest, error) {
	m := new(ExtensionRunRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExtensionServiceServer is the server API for ExtensionService service.
// All implementations must embed UnimplementedExtensionServiceServer
// for forward compatibility
type ExtensionServiceServer interface {
	HealthCheck(context.Context, *ExtensionHealthCheckRequest) (*ExtensionHealthCheckResponse, error)
	SchemaStream(ExtensionService_SchemaStreamServer) error
	RunStream(ExtensionService_RunStreamServer) error
	mustEmbedUnimplementedExtensionServiceServer()
}

// UnimplementedExtensionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedExtensionServiceServer struct {
}

func (UnimplementedExtensionServiceServer) HealthCheck(context.Context, *ExtensionHealthCheckRequest) (*ExtensionHealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedExtensionServiceServer) SchemaStream(ExtensionService_SchemaStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SchemaStream not implemented")
}
func (UnimplementedExtensionServiceServer) RunStream(ExtensionService_RunStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method RunStream not implemented")
}
func (UnimplementedExtensionServiceServer) mustEmbedUnimplementedExtensionServiceServer() {}

// UnsafeExtensionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExtensionServiceServer will
// result in compilation errors.
type UnsafeExtensionServiceServer interface {
	mustEmbedUnimplementedExtensionServiceServer()
}

func RegisterExtensionServiceServer(s grpc.ServiceRegistrar, srv ExtensionServiceServer) {
	s.RegisterService(&ExtensionService_ServiceDesc, srv)
}

func _ExtensionService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtensionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExtensionServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExtensionService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExtensionServiceServer).HealthCheck(ctx, req.(*ExtensionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExtensionService_SchemaStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExtensionServiceServer).SchemaStream(&extensionServiceSchemaStreamServer{stream})
}

type ExtensionService_SchemaStreamServer interface {
	Send(*ExtensionSchemaRequest) error
	Recv() (*ExtensionResult, error)
	grpc.ServerStream
}

type extensionServiceSchemaStreamServer struct {
	grpc.ServerStream
}

func (x *extensionServiceSchemaStreamServer) Send(m *ExtensionSchemaRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *extensionServiceSchemaStreamServer) Recv() (*ExtensionResult, error) {
	m := new(ExtensionResult)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExtensionService_RunStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExtensionServiceServer).RunStream(&extensionServiceRunStreamServer{stream})
}

type ExtensionService_RunStreamServer interface {
	Send(*ExtensionRunRequest) error
	Recv() (*ExtensionResult, error)
	grpc.ServerStream
}

type extensionServiceRunStreamServer struct {
	grpc.ServerStream
}

func (x *extensionServiceRunStreamServer) Send(m *ExtensionRunRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *extensionServiceRunStreamServer) Recv() (*ExtensionResult, error) {
	m := new(ExtensionResult)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ExtensionService_ServiceDesc is the grpc.ServiceDesc for ExtensionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExtensionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.ExtensionService",
	HandlerType: (*ExtensionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _ExtensionService_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SchemaStream",
			Handler:       _ExtensionService_SchemaStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RunStream",
			Handler:       _ExtensionService_RunStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "engine/engine.proto",
}

const (
	FlowJobCronService_Query_FullMethodName      = "/engine.FlowJobCronService/Query"
	FlowJobCronService_Get_FullMethodName        = "/engine.FlowJobCronService/Get"
	FlowJobCronService_Delete_FullMethodName     = "/engine.FlowJobCronService/Delete"
	FlowJobCronService_Update_FullMethodName     = "/engine.FlowJobCronService/Update"
	FlowJobCronService_Replace_FullMethodName    = "/engine.FlowJobCronService/Replace"
	FlowJobCronService_Create_FullMethodName     = "/engine.FlowJobCronService/Create"
	FlowJobCronService_CreateMany_FullMethodName = "/engine.FlowJobCronService/CreateMany"
	FlowJobCronService_DeleteMany_FullMethodName = "/engine.FlowJobCronService/DeleteMany"
)

// FlowJobCronServiceClient is the client API for FlowJobCronService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowJobCronServiceClient interface {
	Query(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error)
	Get(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error)
	Delete(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error)
	Update(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error)
	Replace(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error)
	Create(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error)
	CreateMany(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error)
	DeleteMany(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error)
}

type flowJobCronServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowJobCronServiceClient(cc grpc.ClientConnInterface) FlowJobCronServiceClient {
	return &flowJobCronServiceClient{cc}
}

func (c *flowJobCronServiceClient) Query(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) Get(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) Delete(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) Update(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) Replace(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Replace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) Create(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) CreateMany(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_CreateMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowJobCronServiceClient) DeleteMany(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowJobCronService_DeleteMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowJobCronServiceServer is the server API for FlowJobCronService service.
// All implementations must embed UnimplementedFlowJobCronServiceServer
// for forward compatibility
type FlowJobCronServiceServer interface {
	Query(context.Context, *api.QueryRequest) (*api.Response, error)
	Get(context.Context, *api.GetOrDeleteRequest) (*api.Response, error)
	Delete(context.Context, *api.GetOrDeleteRequest) (*api.Response, error)
	Update(context.Context, *api.UpdateRequest) (*api.Response, error)
	Replace(context.Context, *api.UpdateRequest) (*api.Response, error)
	Create(context.Context, *api.CreateRequest) (*api.Response, error)
	CreateMany(context.Context, *api.CreateRequest) (*api.Response, error)
	DeleteMany(context.Context, *api.QueryRequest) (*api.Response, error)
	mustEmbedUnimplementedFlowJobCronServiceServer()
}

// UnimplementedFlowJobCronServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFlowJobCronServiceServer struct {
}

func (UnimplementedFlowJobCronServiceServer) Query(context.Context, *api.QueryRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedFlowJobCronServiceServer) Get(context.Context, *api.GetOrDeleteRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFlowJobCronServiceServer) Delete(context.Context, *api.GetOrDeleteRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFlowJobCronServiceServer) Update(context.Context, *api.UpdateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedFlowJobCronServiceServer) Replace(context.Context, *api.UpdateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Replace not implemented")
}
func (UnimplementedFlowJobCronServiceServer) Create(context.Context, *api.CreateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedFlowJobCronServiceServer) CreateMany(context.Context, *api.CreateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMany not implemented")
}
func (UnimplementedFlowJobCronServiceServer) DeleteMany(context.Context, *api.QueryRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMany not implemented")
}
func (UnimplementedFlowJobCronServiceServer) mustEmbedUnimplementedFlowJobCronServiceServer() {}

// UnsafeFlowJobCronServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowJobCronServiceServer will
// result in compilation errors.
type UnsafeFlowJobCronServiceServer interface {
	mustEmbedUnimplementedFlowJobCronServiceServer()
}

func RegisterFlowJobCronServiceServer(s grpc.ServiceRegistrar, srv FlowJobCronServiceServer) {
	s.RegisterService(&FlowJobCronService_ServiceDesc, srv)
}

func _FlowJobCronService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Query(ctx, req.(*api.QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.GetOrDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Get(ctx, req.(*api.GetOrDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.GetOrDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Delete(ctx, req.(*api.GetOrDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Update(ctx, req.(*api.UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Replace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Replace(ctx, req.(*api.UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).Create(ctx, req.(*api.CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_CreateMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).CreateMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_CreateMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).CreateMany(ctx, req.(*api.CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowJobCronService_DeleteMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowJobCronServiceServer).DeleteMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowJobCronService_DeleteMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowJobCronServiceServer).DeleteMany(ctx, req.(*api.QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FlowJobCronService_ServiceDesc is the grpc.ServiceDesc for FlowJobCronService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FlowJobCronService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.FlowJobCronService",
	HandlerType: (*FlowJobCronServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _FlowJobCronService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FlowJobCronService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FlowJobCronService_Delete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FlowJobCronService_Update_Handler,
		},
		{
			MethodName: "Replace",
			Handler:    _FlowJobCronService_Replace_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _FlowJobCronService_Create_Handler,
		},
		{
			MethodName: "CreateMany",
			Handler:    _FlowJobCronService_CreateMany_Handler,
		},
		{
			MethodName: "DeleteMany",
			Handler:    _FlowJobCronService_DeleteMany_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine/engine.proto",
}

const (
	FlowLogCronService_Query_FullMethodName      = "/engine.FlowLogCronService/Query"
	FlowLogCronService_Get_FullMethodName        = "/engine.FlowLogCronService/Get"
	FlowLogCronService_Delete_FullMethodName     = "/engine.FlowLogCronService/Delete"
	FlowLogCronService_Update_FullMethodName     = "/engine.FlowLogCronService/Update"
	FlowLogCronService_Create_FullMethodName     = "/engine.FlowLogCronService/Create"
	FlowLogCronService_CreateMany_FullMethodName = "/engine.FlowLogCronService/CreateMany"
	FlowLogCronService_DeleteMany_FullMethodName = "/engine.FlowLogCronService/DeleteMany"
)

// FlowLogCronServiceClient is the client API for FlowLogCronService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowLogCronServiceClient interface {
	Query(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error)
	Get(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error)
	Delete(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error)
	Update(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error)
	Create(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error)
	CreateMany(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error)
	DeleteMany(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error)
}

type flowLogCronServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowLogCronServiceClient(cc grpc.ClientConnInterface) FlowLogCronServiceClient {
	return &flowLogCronServiceClient{cc}
}

func (c *flowLogCronServiceClient) Query(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) Get(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) Delete(ctx context.Context, in *api.GetOrDeleteRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) Update(ctx context.Context, in *api.UpdateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) Create(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) CreateMany(ctx context.Context, in *api.CreateRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_CreateMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowLogCronServiceClient) DeleteMany(ctx context.Context, in *api.QueryRequest, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, FlowLogCronService_DeleteMany_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowLogCronServiceServer is the server API for FlowLogCronService service.
// All implementations must embed UnimplementedFlowLogCronServiceServer
// for forward compatibility
type FlowLogCronServiceServer interface {
	Query(context.Context, *api.QueryRequest) (*api.Response, error)
	Get(context.Context, *api.GetOrDeleteRequest) (*api.Response, error)
	Delete(context.Context, *api.GetOrDeleteRequest) (*api.Response, error)
	Update(context.Context, *api.UpdateRequest) (*api.Response, error)
	Create(context.Context, *api.CreateRequest) (*api.Response, error)
	CreateMany(context.Context, *api.CreateRequest) (*api.Response, error)
	DeleteMany(context.Context, *api.QueryRequest) (*api.Response, error)
	mustEmbedUnimplementedFlowLogCronServiceServer()
}

// UnimplementedFlowLogCronServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFlowLogCronServiceServer struct {
}

func (UnimplementedFlowLogCronServiceServer) Query(context.Context, *api.QueryRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedFlowLogCronServiceServer) Get(context.Context, *api.GetOrDeleteRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFlowLogCronServiceServer) Delete(context.Context, *api.GetOrDeleteRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFlowLogCronServiceServer) Update(context.Context, *api.UpdateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedFlowLogCronServiceServer) Create(context.Context, *api.CreateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedFlowLogCronServiceServer) CreateMany(context.Context, *api.CreateRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMany not implemented")
}
func (UnimplementedFlowLogCronServiceServer) DeleteMany(context.Context, *api.QueryRequest) (*api.Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMany not implemented")
}
func (UnimplementedFlowLogCronServiceServer) mustEmbedUnimplementedFlowLogCronServiceServer() {}

// UnsafeFlowLogCronServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowLogCronServiceServer will
// result in compilation errors.
type UnsafeFlowLogCronServiceServer interface {
	mustEmbedUnimplementedFlowLogCronServiceServer()
}

func RegisterFlowLogCronServiceServer(s grpc.ServiceRegistrar, srv FlowLogCronServiceServer) {
	s.RegisterService(&FlowLogCronService_ServiceDesc, srv)
}

func _FlowLogCronService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).Query(ctx, req.(*api.QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.GetOrDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).Get(ctx, req.(*api.GetOrDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.GetOrDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).Delete(ctx, req.(*api.GetOrDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).Update(ctx, req.(*api.UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).Create(ctx, req.(*api.CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_CreateMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).CreateMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_CreateMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).CreateMany(ctx, req.(*api.CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlowLogCronService_DeleteMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowLogCronServiceServer).DeleteMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FlowLogCronService_DeleteMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowLogCronServiceServer).DeleteMany(ctx, req.(*api.QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FlowLogCronService_ServiceDesc is the grpc.ServiceDesc for FlowLogCronService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FlowLogCronService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "engine.FlowLogCronService",
	HandlerType: (*FlowLogCronServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _FlowLogCronService_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FlowLogCronService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FlowLogCronService_Delete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FlowLogCronService_Update_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _FlowLogCronService_Create_Handler,
		},
		{
			MethodName: "CreateMany",
			Handler:    _FlowLogCronService_CreateMany_Handler,
		},
		{
			MethodName: "DeleteMany",
			Handler:    _FlowLogCronService_DeleteMany_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "engine/engine.proto",
}
